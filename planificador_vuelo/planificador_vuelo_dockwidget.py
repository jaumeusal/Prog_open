# -*- coding: utf-8 -*-
"""
/***************************************************************************
 PlanificadorVueloDockWidget
                                 A QGIS plugin
 Planificador de vuelos UAV
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2023-05-28
        git sha              : $Format:%H$
        copyright            : (C) 2023 by Jaume Cazorla Milla
        email                : jaume.cazorla@usal.es
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os
import math, processing
import geopandas as gpd

from qgis.PyQt import QtGui, QtWidgets, uic
from qgis.PyQt.QtCore import pyqtSignal
from qgis.core import QgsProject,QgsDataProvider,QgsVectorLayer,QgsFeature,QgsGeometry,QgsField

FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'planificador_vuelo_dockwidget_base.ui'))


class PlanificadorVueloDockWidget(QtWidgets.QDockWidget, FORM_CLASS):

    closingPlugin = pyqtSignal()

    def __init__(self, parent=None):
        """Constructor."""
        super(PlanificadorVueloDockWidget, self).__init__(parent)
        # Set up the user interface from Designer.
        # After setupUI you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://doc.qt.io/qt-5/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setupUi(self)
        self.btn_calculo.clicked.connect(self.calcular_datos)
        self.qfw_selector.setFilter("Shapefile(*.shp)")

    def closeEvent(self, event):
        self.closingPlugin.emit()
        event.accept()

    def calcular_datos(self, event):
        #test valores exactos
        """
        fver_px= 5304
        fhor_px= 7952
        focal= 34
        t_px= 4.5
        solape= 40
        altura= 120
        """
        #cargamos los valores anadidos por el usuario
        fhor_px= float(self.txt_fhorizontal.text())
        fver_px= float(self.txt_fvertical.text())
        t_px= float(self.txt_tamanopixel.text())
        focal= float(self.txt_focal.text())
        altura= float(self.txt_altitud.text())
        solape= float(self.txt_solape.text())
        Numero_lineas_vuelo = int(self.txt_numero_lineas.text()) #cantidad_lineas

        #calculos matematicos
        #tamano en mm
        fhor_mm= (fhor_px*t_px)/1000
        fver_mm= (fver_px*t_px)/1000
        #fov
        fov_h= math.atan(fhor_mm / (2 * focal)) * 180 / math.pi * 2
        fov_v = math.atan(fver_mm / (2 * focal)) * 180 / math.pi * 2
        # redondear valor fov
        fov_mostrar=round(fov_h,0)
        #gsd
        gsd=t_px*0.000001*altura/(focal/1000)
        # redondear valor distancia gsd
        gsd_mostrar = round(gsd, 3)
        #area cubierta
        area_cubierta_h=fhor_px*gsd
        area_cubierta_v=fver_px*gsd
        #distancia entre lineas de vuelo
        solape_entero = solape / 100
        distancia_lineas=area_cubierta_h*(1-solape_entero)
        #redondear valor distancia lineas de vuelo
        distancia_lineas_mostrar= round(distancia_lineas, 0)

        #mostrar los datos calculados por pantalla
        self.txt_fov.setText(str(fov_mostrar))
        self.txt_gsd.setText(str(gsd_mostrar))
        self.txt_distancia.setText(str(distancia_lineas_mostrar))
        #pasar pasar a int los datos float
        distancia_lineas_int=int(distancia_lineas)

        # leer archivo alineacion
        ruta_shapefile = self.qfw_selector.filePath()

        #cambiamos el crs de la capa para trabajar en ETRS89 UTM 30N en metros
        alineacion_no_crs = gpd.read_file(ruta_shapefile)
        crs_deseado = 'EPSG:25830'
        alineacion = alineacion_no_crs.to_crs(crs_deseado)

        #asignamos la geometria para la linea
        linea_original = alineacion['geometry'][0]

        # lista vacia para almacenar las lineas paralelas a la alineacion
        lineas_paralelas = []

        #anadimos la alineacion como linea original al vuelo
        linea_paralela_0 = linea_original.parallel_offset(0, 'left', join_style=2)
        lineas_paralelas.append(linea_paralela_0)

        #quitamos una linea de vuelo, ya que la primera sera la original
        Numero_lineas_vuelo_menos_uno=Numero_lineas_vuelo-1

        #creamos un bucle para el numero de lineas de vuelo
        for i in range(Numero_lineas_vuelo_menos_uno):
            #calculamos el desplazamiento de cada linea paralela
            desplazamiento = (i + 1) * distancia_lineas_int

            #creamos la linea paralela
            linea_paralela = linea_original.parallel_offset(desplazamiento, 'left', join_style=2)

            #anadimos la linea a la lista de lineas
            lineas_paralelas.append(linea_paralela)

        # creamos el vector de vuelo
        vector_vuelo = gpd.GeoDataFrame(geometry=lineas_paralelas)

        #asignamos el crs al vector de vuelo
        vector_vuelo.crs = 'EPSG:25830'

        #guardamos el shapefile con el vuelo
        ruta_salida = 'C:/Users/Jaume/Documents/Master/Programacion_open/Final/Planner_md/salida.shp'
        vector_vuelo.to_file(ruta_salida)

        #a√±adimos el shapefile a nuestro proyecto de qgis
        vuelo = QgsVectorLayer(ruta_salida, 'Plan_vuelo', 'ogr')
        QgsProject.instance().addMapLayer(vuelo)

